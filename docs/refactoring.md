### v3.1 - 재생 중 설정 변경 방지 (2025-01-XX)
**문제**: 재생 중 BPM/박자 변경 시 클라이언트 간 불일치 지속 발생

**조치**:
- **재생 중 설정 변경 차단**: UI 레벨에서 완전 차단
  - 재생 중에는 설정 UI 비활성화 (opacity 0.5, pointer-events: none)
  - 경고 메시지와 정지 버튼 제공
- **설정 버튼 클릭 시 자동 정지**: 사용자 경험 개선
  - 설정 버튼 클릭 시 재생 중이면 자동으로 메트로놈 정지
  - 정지 후 설정 바텀시트 열기
- **서버 측 설정 변경 시 정지**: 일관성 보장
  - `ChangeTempoWithStop`, `ChangeBeatsWithStop` 메서드 추가
  - 재생 중 설정 변경 시 자동으로 메트로놈 정지 후 변경
  - 모든 클라이언트에서 동시에 정지되어 일관성 보장

**효과**:
- 재생 중 설정 변경으로 인한 불일치 완전 제거
- 사용자 경험 개선 (명확한 안내와 자동 정지)
- 모든 클라이언트에서 일관된 상태 유지

### v3.0 - Web Audio API 도입 및 동기화 개선 (2025-01-XX)
**문제**: 오디오 파일 로딩 지연, BPM 변경 시 클라이언트 불일치, 과도한 동기화

**조치**:
- **Web Audio API 도입**: 오디오 파일 대신 실시간 사운드 생성
  - `createClickSound()` 메서드로 악센트(1200Hz)와 일반(800Hz) 비트 구분
  - 파일 로딩 불필요, 네트워크 독립적, 즉시 재생 가능
- **서버 중심 BPM 변경**: 로컬 즉시 반영 제거, 서버에서 정확한 동기화
  - 서버에서 박자 위상을 정확히 계산하여 브로드캐스트
  - 클라이언트는 서버 응답을 기다린 후 동기화
- **동기화 최적화**: 과도한 동기화 방지
  - 동기화 빈도: 1초 → 5초
  - 동기화 임계값: 50ms → 200ms
  - 안전장치: 2박자 이상의 큰 차이는 무시

**효과**:
- 파일 로딩 지연 완전 제거
- BPM 변경 시 클라이언트 간 완벽한 동기화
- 안정적인 박자 유지, 네트워크 오류 방지

### v2.4 - 위상 동기화/입력 UX 개선 (2025-09-15)
**문제**: 템포 변화 시 UI 비트가 밀림, ScrollPicker가 스냅 완료 후에만 값 변경

**조치**:
- 엔진 `setOnBeat` 콜백 추가 → UI는 엔진 비트와 직접 동기화
- `roomPage` 로컬 setInterval 카운터 제거
- ScrollPicker 이동 중에도 중앙값을 즉시 `onChange`로 반영
- 정적 자산 경로/캐시 안정화(`resolveAssetUrl`, `force-cache`)

**효과**:
- 템포 글라이드 동안에도 1-2-3-4 위상 유지
- 스크롤 조작감 향상, 지연 없이 실시간 반영
# 리팩토링 가이드

## 우선순위
1. 가독성/명확성 향상(네이밍/분리)
2. 결합도↓, 응집도↑
3. 에러 처리/복구 경로 강화
4. 성능/자원 사용 최적화

## 완료된 리팩토링

### v2.3 - 오디오 초기화/메트로놈 안정화 (2025-09-15)
**문제**: 첫 진입 재생 불가, ‘오디오 준비’가 1회에 동작하지 않음, 중복 재생, decodeAudioData 에러

**조치**:
- 메트로놈 인스턴스 선생성(WebSocket과 독립) → WebSocket은 `setWebSocket`으로 주입
- 시작 버튼에서 자동 초기화(필요 시 `initializeAudio()` → 성공 시 `start()`)
- WebSocket 리스너 중복 방지(기존 핸들러 제거 후 재바인딩)
- `decodeAudioData` 호환 래퍼/AudioContext 로컬 고정/`resume()` 보강
- Tempo Glide 도입: 템포 변경 시 루프 유지, 일정 시간 동안 자연스럽게 목표 BPM으로 수렴

**효과**:
- 첫 클릭에서 바로 초기화+재생
- 재연결/상태변경에도 중복 재생 제거
- 브라우저 호환성/안정성 향상

### v2.2 - 메트로놈 엔진 완전 재작성 (2025-9-14)
**목표**: 안정적인 메트로놈 재생을 위한 엔진 개선

**변경 사항**:
- **기존 metronome.ts 삭제**: Web Worker 기반 복잡한 구현 제거
- **새로운 metronome.ts 생성**: 
  - requestAnimationFrame 기반 간단하고 안정적인 구현
  - 중복 재생 방지 로직 강화 (`isStarting` 플래그)
  - 사용자 상호작용 후 오디오 초기화
  - 명확한 상태 관리 및 에러 처리
- **useMetronome.ts 개선**:
  - 오디오 준비 상태 관리 추가
  - 초기화 상태 표시
  - 타입 안전성 강화
- **MetronomeControls.tsx 개선**:
  - 오디오 초기화 버튼 추가
  - 초기화 상태에 따른 UI 변경
  - 로딩 애니메이션 추가

**개선 효과**:
- ✅ 첫 진입 시 재생 불가 문제 해결
- ✅ 중복 재생 문제 완전 해결
- ✅ 더 안정적인 타이밍 제공
- ✅ 사용자 경험 개선 (오디오 상태 표시)
- ✅ 코드 복잡도 대폭 감소

### v2.1 - MetronomeControls 컴포넌트 분리 (2025-9-14)
**목표**: UI 적으로 분리되어야 하는 부분을 1depth 깊게 변경

**변경 사항**:
- **MetronomeControls.tsx 삭제**: 기존 단일 컴포넌트 제거
- **MetronomeControls.tsx 생성**: 
  - 메인 화면에 표시되는 기본 컨트롤
  - 현재 BPM과 박자 상태 표시
  - 오디오 초기화 버튼
  - 시작/정지 버튼
  - 설정 버튼 (톱니바퀴 아이콘)
- **SettingsBottomSheet.tsx 생성**:
  - 설정 버튼 클릭 시 나타나는 바텀시트
  - BPM ScrollPicker (세로 스크롤)
  - 박자 HorizontalScrollPicker (가로 스크롤)
  - 탭 템포 버튼과 초기화 버튼
  - 오버레이와 닫기 버튼
- **roomPage.tsx 수정**:
  - 새로운 컴포넌트들 import
  - `isSettingsOpen` 상태 추가
  - 설정 바텀시트 열기/닫기 핸들러 추가

**개선 효과**:
- ✅ 깔끔한 메인 화면: 기본 컨트롤만 표시
- ✅ 1depth 깊은 설정: 설정 버튼을 통한 세부 조절 기능 접근
- ✅ 모바일 친화적: 바텀시트 형태로 모바일에서 사용하기 편리
- ✅ 컴포넌트 분리: 관심사 분리로 유지보수성 향상

## 권장 리팩토링 포인트
- `utils/metronome.ts`: 사운드 로드/스케줄러/WS 핸들러를 모듈화(파일 분할) 고려
- `useWebSocket`: 에러/클로즈 사유 로깅 및 지표 훅 추가
- `http` 인터셉터: 에러 표준화 포맷 도입
- 타입 강화: 서버 계약 타입 일부 `unknown` → 명시 인터페이스

## 점진적 접근
- 작은 PR 단위(≤200 라인)
- 동작 동일성 보장 → E2E/수동 체크리스트 동봉

## v3.2 - 모바일 터치 이벤트 최적화

### 문제
- **PC 환경**: 모든 버튼이 정상 작동
- **모바일 환경**: SettingsBottomSheet의 버튼들이 터치에 반응하지 않음
- **ShareBottomSheet**: 모바일에서 정상 작동 (대조군)

### 원인 분석
1. **이벤트 처리 차이**: PC는 `onClick` 이벤트만으로 충분하지만, 모바일에서는 터치 이벤트가 `onClick`을 제대로 트리거하지 않음
2. **CSS 설정 충돌**: `pointerEvents: 'none'` 설정이 모바일에서 터치 이벤트를 완전히 차단
3. **복잡한 터치 최적화**: 과도한 `touchAction`, `userSelect` 설정이 예상치 못한 충돌 발생
4. **구조적 차이**: ShareBottomSheet와 SettingsBottomSheet의 CSS 구조가 달라서 일관성 부족

### 실행한 작업
#### **1. 이중 이벤트 핸들러 적용**
```typescript
// 모든 버튼에 onClick + onTouchStart 적용
<Button 
  onClick={() => {
    console.log('버튼 클릭됨');
    onClose();
  }}
  onTouchStart={(e) => {
    console.log('버튼 터치됨');
    e.preventDefault();
    onClose();
  }}
>
```

#### **2. 구조적 단순화**
- **바텀시트 컨테이너**: ShareBottomSheet와 동일한 `insetX: 0` 사용
- **헤더 구조**: 단순한 구조로 변경
- **복잡한 CSS 제거**: `maxH`, `overflow`, `pointerEvents` 등 제거

#### **3. 디버깅 시스템 구축**
- **콘솔 로그**: 각 이벤트 발생 시 로그 출력
- **이벤트 구분**: 클릭과 터치 이벤트를 구분하여 로깅
- **문제 진단**: 모바일에서 어떤 이벤트가 발생하는지 확인 가능

#### **4. 적용된 컴포넌트**
- **SettingsBottomSheet**: 오버레이, 닫기 버튼, Tab 버튼, 정지 후 설정 버튼
- **모든 버튼**: 이중 이벤트 핸들러로 PC/모바일 호환성 확보

### 효과
- **PC 환경**: 기존과 동일하게 정상 작동
- **모바일 환경**: 모든 버튼이 터치에 정상 반응
- **크로스 플랫폼**: PC와 모바일 모두에서 안정적인 사용자 경험 제공
- **디버깅**: 문제 발생 시 쉽게 진단 가능

### 교훈
- **모바일 터치 이벤트**: `onClick`만으로는 부족하고 `onTouchStart`도 필요
- **CSS 설정**: 과도한 최적화가 오히려 문제를 일으킬 수 있음
- **구조적 일관성**: 비슷한 컴포넌트는 동일한 구조를 유지하는 것이 좋음
- **디버깅 시스템**: 문제 해결을 위한 로깅 시스템의 중요성

## v3.3 - 스크롤 피커 성능 최적화

### 문제
- **렌더링 성능**: 모든 아이템을 매번 렌더링하여 버벅임 발생
- **메모리 사용량**: 대량의 DOM 노드로 인한 메모리 과다 사용
- **스크롤 지연**: 복잡한 계산과 불필요한 리렌더링으로 인한 성능 저하

### 원인 분석
- **전체 렌더링**: `values.map()`으로 모든 아이템을 매번 렌더링
- **복잡한 계산**: 각 아이템마다 `opacity`, `scale` 계산
- **불필요한 리렌더링**: `handleMove`에서 `onChange` 호출로 인한 상태 변경
- **CPU 기반 애니메이션**: GPU 가속 미활용

### 실행한 작업
1. **가상화 구현**:
   - `visibleRange` 메모이제이션으로 화면에 보이는 아이템만 계산
   - 상단/하단 패딩으로 자연스러운 스크롤 경험 제공
   - 렌더링 아이템 수를 95% 감소 (200개 → 8-10개)

2. **메모이제이션 적용**:
   - `values` 배열을 `useMemo`로 캐싱
   - `selectedIndex` 계산 결과 메모이제이션
   - `centerOffset` 계산 결과 캐싱

3. **디바운싱 구현**:
   - onChange 호출을 16ms(60fps)로 제한
   - `onChangeTimeoutRef`로 타이머 생명주기 관리
   - 컴포넌트 언마운트 시 타이머 정리

4. **GPU 가속 최적화**:
   - `translate3d(0, 0, 0)`로 하드웨어 가속 활성화
   - `willChange` 속성으로 브라우저 최적화 힌트 제공 (드래그 중에만 활성화)
   - CSS Transform을 통한 GPU 레이어 분리

5. **드래그 최적화 (v3.3.1)**:
   - 드래그 중 onChange 호출 중단으로 성능 향상
   - CSS transition 비활성화로 부드러운 드래그 경험
   - opacity/scale 계산 단순화로 렌더링 부하 감소
   - `isDragging` 상태를 통한 조건부 렌더링

### 적용된 컴포넌트
- **ScrollPicker**: BPM 설정용 세로 스크롤 피커
- **HorizontalScrollPicker**: 박자 설정용 가로 스크롤 피커

### 효과
- **렌더링 성능**: 95% 개선 (200개 → 8-10개 아이템)
- **메모리 사용량**: 대폭 감소
- **스크롤 성능**: 부드러운 60fps 달성
- **드래그 성능**: 자연스러운 BPM 변화, 버벅임 해결
- **사용자 경험**: 매끄러운 스크롤과 즉시 반응하는 드래그

### 교훈
- **가상화의 중요성**: 대량 데이터 렌더링 시 필수적
- **메모이제이션**: 불필요한 재계산 방지의 핵심
- **디바운싱**: 과도한 상태 업데이트 방지
- **GPU 가속**: 하드웨어 리소스 활용의 중요성
- **성능 모니터링**: 사용자 경험 개선의 지표

## v3.3.2 - 스크롤 피커 중앙 정렬 및 색상 개선

### 문제
- **중앙 정렬 오류**: 스크롤 후 정확히 가운데에 오지 않으면 선택되지 않는 문제
- **색상 문제**: 회색으로 색이 변하여 가독성이 떨어지는 문제
- **선택 상태 불일치**: 드래그 중 선택 상태가 정확히 반영되지 않는 문제

### 원인 분석
- **부정확한 스냅**: `snapToValue` 함수가 정확한 중앙 정렬을 보장하지 못함
- **색상 체계 문제**: 회색(`neutral.300`)이 가독성을 떨어뜨림
- **선택 로직 불일치**: `val === value` 비교로 인한 실시간 선택 상태 반영 부족

### 실행한 작업
1. **정확한 중앙 정렬 구현**:
   - `currentCenterIndex = Math.round(-offset / itemHeight)`로 실시간 중앙 인덱스 계산
   - `snapToValue` 대신 직접 `setOffset`과 `onChange` 호출로 정밀한 제어
   - `targetOffset = -clampedIndex * itemHeight`로 완벽한 중앙 정렬

2. **색상 시스템 개선**:
   - 회색(`neutral.300`) 대신 흰색(`white`) 사용
   - 선택된 값은 오렌지(`orange.400`), 선택되지 않은 값은 흰색으로 명확한 구분
   - 가독성 향상을 위한 색상 체계 개선

3. **실시간 선택 상태 관리**:
   - `isSelected = actualIndex === currentCenterIndex`로 실시간 선택 상태 확인
   - 드래그 중에도 현재 중앙 값이 즉시 선택된 상태로 표시
   - 오프셋과 선택 상태의 완벽한 동기화

### 적용된 컴포넌트
- **ScrollPicker**: BPM 설정용 세로 스크롤 피커
- **HorizontalScrollPicker**: 박자 설정용 가로 스크롤 피커

### 효과
- **정확한 선택**: 스크롤 후 정확히 중앙에 있는 값이 선택됨
- **즉시 반영**: 드래그 중에도 현재 중앙 값이 시각적으로 표시됨
- **깔끔한 UI**: 회색 대신 흰색으로 더 깔끔한 사용자 경험
- **일관된 동작**: 두 스크롤 피커 모두 동일한 정밀한 동작 보장

### 교훈
- **정확한 계산의 중요성**: 수학적 정밀도가 사용자 경험에 직접적인 영향
- **색상 체계의 중요성**: 가독성과 사용성에 미치는 시각적 요소의 영향
- **실시간 피드백**: 사용자 상호작용 중 즉시 반영되는 피드백의 중요성
- **일관성**: 여러 컴포넌트 간 동일한 동작 패턴의 중요성

## 성능 체크
- 모바일 저사양에서 오디오 끊김 여부
- 재연결 시 UI 블로킹 없는지
